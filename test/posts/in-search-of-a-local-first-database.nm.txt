# {"type":"header","depth":0}

  In Search of a Local-First Database

# {"type":"note","depth":1}

  {"tags": ["local-first"], "date": "2020-1-14 10:39:34", "description": "My criteria for evaluating syncing solutions", "draft": true, "featured": true, "author": "Jared Forsyth", "title": "In Search of a Local-First Database"}

# {"type":"normal","depth":1}

  I've been wrestling with the issue of "data storage that syncs and works offline" for a number of years now, and have gotten 80% of the way a number of different implementations, but always ultimately get stymied by the little things, like "how do I make it not break".

# {"type":"normal","depth":1}

  Recently, I've been re-energized in my search by the wonderful [Local-first software](https://www.inkandswitch.com/local-first.html) article by Ink & Switch, and then by James Long's dotConf talk, [CRDTs for Mortals](https://www.dotconferences.com/2019/12/james-long-crdts-for-mortals).

# {"type":"normal","depth":1}

  I'm now building yet another app, and it should be a fairly good testbed for evaluating various approaches that claim to solve this problem. So far I've tried gun.js, pouchdb, and remoteStorage, and I plan on looking into y.js, swarmjs, automerge, and anything else that looks like it could do the trick. In following posts I will detail my thoughts on these various solutions, but first I'll outline **my criteria for evaluating a local-first database**. I split them up into concerns of **Correctness**, **Cost** and **Flexibility**.

# {"type":"header","depth":1}

  Correctness

# {"type":"list","depth":2}



# {"type":"normal","depth":3}

  How are conflicts handled? Does it require the client (programmer) to write bespoke conflict resolution code?

# {"type":"normal","depth":3}

  How "bullet proof" is it? How easy is it to get it into a broken state (e.g. where different clients continue to see inconsistent data dispite syncing)?

# {"type":"normal","depth":3}

  Is there consistency verification built-in, to detect if you're in a broken state? 

# {"type":"normal","depth":3}

  How well does sync preserve intent? In what cases would a user's work be "lost" unexpectedly?

# {"type":"header","depth":1}

  Cost

# {"type":"list","depth":2}



# {"type":"normal","depth":3}

  How much data does the client need to store to fully replicate (full offline data access & editing)? Hopefully O(size of the data) and not O(size of the data + number of changes), with some reasonable constant factor. (this has huge impacts on the "initial app load" time)

# {"type":"normal","depth":3}

  How much data does the server need to store? If it needs to store history, does it support periodic garbage collection?

# {"type":"normal","depth":3}

  What are the transfer costs of the sync protocol? Are you sending the whole dataset with each change, or just deltas?

# {"type":"normal","depth":3}

  How complicated is the server logic? 

# {"type":"normal","depth":3}

  How's the code quality, maintenance level, test coverage, etc.?

# {"type":"header","depth":1}

  Flexibility

# {"type":"list","depth":2}



# {"type":"normal","depth":3}

  How does it react to schema changes? If you need to add an attribute to an object, can you?

# {"type":"normal","depth":3}

  Is the shape of data restricted to anything less than full JSON? e.g. are nested objects, and arrays supported?

# {"type":"normal","depth":3}

  Can it be used with an existing (server-side or client-side) database (sqlite, postgres, etc.) or do you have to use a whole new data storage solution?

# {"type":"normal","depth":3}

  Can it sync with Google Drive, Dropbox, etc. such that each user manages their own backend storage?

# {"type":"normal","depth":3}

  Does it require all data to live in memory, or can it work with mostly-persisted data? (such that large datasets are possible)

# {"type":"normal","depth":3}

  Does it support e2e encryption?

# {"type":"normal","depth":3}

  Does it bake in auth, or can you use an existing authentication setup?

# {"type":"normal","depth":3}

  Is multi-user collaboration possible, where some users only have access to a subset of the data? (think firebase access rules)

# {"type":"normal","depth":3}

  Is collaborative text editing *possible*? (I'm fine paying more for it, in terms of server requirements, data overhead, etc.)

# {"type":"normal","depth":3}

  Does it have the concept of "undo" built-in? At what cost?

# {"type":"normal","depth":3}

  Does it support a fully p2p network setup (no central authority / server)?

# {"type":"header","depth":1}

  Convenience

# {"type":"list","depth":2}

  might get rid of this one tbh

# {"type":"normal","depth":3}

  Are there react.js bindings?

# {"type":"normal","depth":3}

  Is there a reactive api?

# {"type":"normal","depth":1}

  I'll keep this post updated with the results as I evaluate various solutions.